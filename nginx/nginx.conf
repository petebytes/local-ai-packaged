# Nginx configuration for HTTPS reverse proxy

# SSL settings
ssl_certificate /etc/nginx/certs/local-cert.pem;
ssl_certificate_key /etc/nginx/certs/local-key.pem;

# WebSocket support
map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}

server {
    listen 80;
    server_name *.lan;
    return 301 https://$host$request_uri;
}

# Directory listing page
server {
    listen 443 ssl;
    server_name raven.lan;

    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ /index.html;
    }
}

# Status Dashboard
server {
    listen 443 ssl;
    server_name traefik.lan;

    # Simple status page
    location / {
        return 200 "HTTPS is working correctly!";
        add_header Content-Type text/plain;
    }

    location /status {
        stub_status on;
        access_log off;
    }
}

# n8n
server {
    listen 443 ssl;
    server_name n8n.lan;

    # Increased timeouts for n8n
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Large file upload support
    client_body_timeout 3600s;        # Allow 1 hour for upload
    client_header_timeout 3600s;      # Allow 1 hour for headers
    proxy_request_buffering off;      # Don't buffer - stream directly

    # Increase max body size for file uploads (up to 2GB)
    client_max_body_size 2000M;

    location / {
        # Use a fixed IP address instead of hostname resolution
        proxy_pass http://n8n:5678;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;

        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;

        # No health check - standard nginx doesn't support it
    }

    location /maintenance.html {
        return 200 "The n8n service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}


# Open WebUI
server {
    listen 443 ssl;
    server_name openwebui.lan;

    # Longer timeouts for model operations
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    location / {
        # Direct proxy pass instead of variable
        proxy_pass http://open-webui:8080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Open WebUI service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Kokoro
server {
    listen 443 ssl;
    server_name kokoro.lan;

    # Redirect root to web interface
    location = / {
        return 301 /web/;
    }

    location / {
        # Direct proxy pass instead of variable
        proxy_pass http://localai-kokoro-fastapi-gpu-1:8880;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Kokoro service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}


# Ollama
server {
    listen 443 ssl;
    server_name ollama.lan;

    # Longer timeouts for model operations
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    location / {
        proxy_pass http://localhost:11434;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Ollama service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Supabase
server {
    listen 443 ssl;
    server_name studio.lan;

    location / {
        # Use supabase-studio instead of db
        proxy_pass http://supabase-studio:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Supabase service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Supabase API Gateway
server {
    listen 443 ssl;
    server_name supabase.lan;

    # Longer timeouts might be needed depending on API usage
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    location / {
        # Proxy to the Supabase Kong gateway
        proxy_pass http://kong:8000; # Assuming standard Supabase docker setup
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade"; # For potential WebSockets
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off; # Important for streaming responses
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Supabase API service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}


# NocoDB
server {
    listen 443 ssl;
    server_name nocodb.lan;

    location / {
        proxy_pass http://nocodb:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The NocoDB service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# ComfyUI
server {
    listen 443 ssl;
    server_name comfyui.lan;

    # Longer timeouts for model operations
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    location / {
        proxy_pass http://comfyui:8188;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The ComfyUI service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}


# Crawl4AI
server {
    listen 443 ssl;
    server_name crawl4ai.lan;

    # Longer timeouts might be needed depending on crawl duration
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    location / {
        proxy_pass http://crawl4ai:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade"; # For potential WebSockets
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Crawl4AI service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# WhisperX
server {
    listen 443 ssl;
    server_name whisper.lan;

    # Very long timeouts for transcription of long videos
    proxy_connect_timeout 3600;
    proxy_send_timeout 3600;
    proxy_read_timeout 3600;
    send_timeout 3600;

    # Increase max body size for large video/audio file uploads (up to 2GB)
    client_max_body_size 2048M;

    location / {
        proxy_pass http://whisperx:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The WhisperX service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Wan
server {
    listen 443 ssl;
    server_name wan.lan;

    # Longer timeouts for model operations
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    location / {
        proxy_pass http://host.docker.internal:7860;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Wan service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# InfiniteTalk
server {
    listen 443 ssl;
    server_name infinitetalk.lan;

    # Very long timeouts for video generation
    proxy_connect_timeout 3600;
    proxy_send_timeout 3600;
    proxy_read_timeout 3600;
    send_timeout 3600;

    # Increase max body size for large video/audio file uploads (up to 2GB)
    client_max_body_size 2048M;

    location / {
        proxy_pass http://infinitetalk:8418;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The InfiniteTalk service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}
