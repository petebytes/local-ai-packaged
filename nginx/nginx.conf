# Nginx configuration for HTTPS reverse proxy

# SSL settings
ssl_certificate /etc/nginx/certs/local-cert.pem;
ssl_certificate_key /etc/nginx/certs/local-key.pem;

# WebSocket support
map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}

server {
    listen 80;
    server_name *.lan;
    return 301 https://$host$request_uri;
}

# Directory listing page
server {
    listen 443 ssl;
    server_name raven.lan;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    # Progress tracker API endpoints
    location /api/ {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $progress_backend progress-tracker:5555;
        proxy_pass http://$progress_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # CORS headers for frontend access
        add_header 'Access-Control-Allow-Origin' '*' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type' always;

        if ($request_method = 'OPTIONS') {
            return 204;
        }
    }

    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ /index.html;
    }
}

# Status Dashboard
server {
    listen 443 ssl;
    server_name traefik.lan;

    # Simple status page
    location / {
        return 200 "HTTPS is working correctly!";
        add_header Content-Type text/plain;
    }

    location /status {
        stub_status on;
        access_log off;
    }
}

# n8n
server {
    listen 443 ssl;
    server_name n8n.lan;

    # Increased timeouts for n8n
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Large file upload support
    client_body_timeout 3600s;        # Allow 1 hour for upload
    client_header_timeout 3600s;      # Allow 1 hour for headers
    proxy_request_buffering off;      # Don't buffer - stream directly

    # Increase max body size for file uploads (up to 10GB)
    client_max_body_size 10240M;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    # CORS configuration for webhooks
    location /webhook/ {
        # Hide CORS headers from backend to prevent duplicates
        proxy_hide_header 'Access-Control-Allow-Origin';
        proxy_hide_header 'Access-Control-Allow-Methods';
        proxy_hide_header 'Access-Control-Allow-Headers';
        proxy_hide_header 'Access-Control-Max-Age';

        # Handle preflight OPTIONS requests
        if ($request_method = 'OPTIONS') {
            add_header 'Access-Control-Allow-Origin' 'https://raven.lan' always;
            add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
            add_header 'Access-Control-Allow-Headers' 'Content-Type, Accept' always;
            add_header 'Access-Control-Max-Age' 1728000;
            add_header 'Content-Type' 'text/plain; charset=utf-8';
            add_header 'Content-Length' 0;
            return 204;
        }

        # Add CORS headers to all webhook responses
        add_header 'Access-Control-Allow-Origin' 'https://raven.lan' always;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Accept' always;

        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $n8n_backend n8n:5678;
        proxy_pass http://$n8n_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
    }

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $n8n_backend n8n:5678;
        proxy_pass http://$n8n_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;

        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;

        # No health check - standard nginx doesn't support it
    }

    location /maintenance.html {
        return 200 "The n8n service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}


# Open WebUI
server {
    listen 443 ssl;
    server_name openwebui.lan;

    # Longer timeouts for model operations
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $openwebui_backend open-webui:8080;
        proxy_pass http://$openwebui_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Open WebUI service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Kokoro
server {
    listen 443 ssl;
    server_name kokoro.lan;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    # Redirect root to web interface
    location = / {
        return 301 /web/;
    }

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $kokoro_backend localai-kokoro-fastapi-gpu-1:8880;
        proxy_pass http://$kokoro_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Kokoro service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}


# LM Studio
server {
    listen 443 ssl;
    server_name lmstudio.lan;

    # Longer timeouts for model operations
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    location / {
        proxy_pass http://localhost:1234;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The LM Studio service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Supabase
server {
    listen 443 ssl;
    server_name studio.lan;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $supabase_backend supabase-studio:3000;
        proxy_pass http://$supabase_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Supabase service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Supabase API Gateway
server {
    listen 443 ssl;
    server_name supabase.lan;

    # Longer timeouts might be needed depending on API usage
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $kong_backend kong:8000;
        proxy_pass http://$kong_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade"; # For potential WebSockets
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off; # Important for streaming responses
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Supabase API service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}


# NocoDB
server {
    listen 443 ssl;
    server_name nocodb.lan;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $nocodb_backend nocodb:8080;
        proxy_pass http://$nocodb_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The NocoDB service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# ComfyUI
server {
    listen 443 ssl;
    server_name comfyui.lan;

    # Longer timeouts for model operations
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $comfyui_backend comfyui:8188;
        proxy_pass http://$comfyui_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The ComfyUI service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}


# Crawl4AI
server {
    listen 443 ssl;
    server_name crawl4ai.lan;

    # Longer timeouts might be needed depending on crawl duration
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $crawl4ai_backend crawl4ai:8000;
        proxy_pass http://$crawl4ai_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade"; # For potential WebSockets
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Crawl4AI service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# WhisperX
server {
    listen 443 ssl;
    server_name whisper.lan;

    # Very long timeouts for transcription of long videos
    proxy_connect_timeout 3600;
    proxy_send_timeout 3600;
    proxy_read_timeout 3600;
    send_timeout 3600;

    # Increase max body size for large video/audio file uploads (up to 2GB)
    client_max_body_size 2048M;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $whisperx_backend whisperx:8000;
        proxy_pass http://$whisperx_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The WhisperX service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Wan
server {
    listen 443 ssl;
    server_name wan.lan;

    # Longer timeouts for model operations
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $wan_backend host.docker.internal:7860;
        proxy_pass http://$wan_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Wan service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# Virtual Assistant - NVIDIA powered visual assistant
server {
    listen 443 ssl;
    server_name va.lan;

    # Longer timeouts for AI processing
    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    # Use Docker's internal DNS resolver for runtime resolution
    resolver 127.0.0.11 valid=30s;

    # WebSocket support for real-time video/audio streaming
    location /ws {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $va_backend virtual-assistant-web:8080;
        proxy_pass http://$va_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;
    }

    location / {
        # Use variable to force runtime DNS resolution - nginx won't fail at startup if service doesn't exist
        set $va_backend virtual-assistant-web:8080;
        proxy_pass http://$va_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_intercept_errors on;
        error_page 502 =200 /maintenance.html;
    }

    location /maintenance.html {
        return 200 "The Virtual Assistant service is starting up. Please refresh in a moment.";
        add_header Content-Type text/plain;
    }
}

# InfiniteTalk - Disabled
# server {
#     listen 443 ssl;
#     server_name infinitetalk.lan;
# 
#     # Very long timeouts for video generation
#     proxy_connect_timeout 3600;
#     proxy_send_timeout 3600;
#     proxy_read_timeout 3600;
#     send_timeout 3600;
# 
#     # Increase max body size for large video/audio file uploads (up to 2GB)
#     client_max_body_size 2048M;
# 
#     location / {
#         proxy_pass http://infinitetalk:8418;
#         proxy_http_version 1.1;
#         proxy_set_header Upgrade $http_upgrade;
#         proxy_set_header Connection "upgrade";
#         proxy_set_header Host $host;
#         proxy_set_header X-Real-IP $remote_addr;
#         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#         proxy_set_header X-Forwarded-Proto $scheme;
#         proxy_buffering off;
#         proxy_intercept_errors on;
#         error_page 502 =200 /maintenance.html;
#     }
# 
#     location /maintenance.html {
#         return 200 "The InfiniteTalk service is starting up. Please refresh in a moment.";
#         add_header Content-Type text/plain;
#     }
# }
